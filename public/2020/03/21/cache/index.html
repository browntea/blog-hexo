<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>缓存介绍 | 布朗与茶的空间</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="以下信息及图片收集于网络， 此处仅做整合 什么是缓存 缓： 缓冲，缓解矛盾 （不是缓慢，反而应该是除CPU&#x2F;GPU之外最快的） 存：占有储存空间资源 缓存：缓存就是数据交换的缓冲区。临时存贮的那些交换频繁的数据&#x2F;文件，以便于快速的访问。 缓存的介质类型  内存型缓存 文件型缓存 数据库型缓存  ???">
<meta property="og:type" content="article">
<meta property="og:title" content="缓存介绍">
<meta property="og:url" content="http://browntea.club/2020/03/21/cache/index.html">
<meta property="og:site_name" content="布朗与茶的空间">
<meta property="og:description" content="以下信息及图片收集于网络， 此处仅做整合 什么是缓存 缓： 缓冲，缓解矛盾 （不是缓慢，反而应该是除CPU&#x2F;GPU之外最快的） 存：占有储存空间资源 缓存：缓存就是数据交换的缓冲区。临时存贮的那些交换频繁的数据&#x2F;文件，以便于快速的访问。 缓存的介质类型  内存型缓存 文件型缓存 数据库型缓存  ???">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%201.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%202.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%203.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%204.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%205.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%206.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/v2-e295352c7273887832b6beb185597460_1200x500.jpg">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%207.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%208.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%209.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2010.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2011.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2012.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2013.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2014.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2015.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2016.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2017.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2018.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2019.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2020.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2021.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2022.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2023.png">
<meta property="og:image" content="http://browntea.club/2020/03/21/cache/cache/cache%2024.png">
<meta property="article:published_time" content="2020-03-21T09:36:43.000Z">
<meta property="article:modified_time" content="2020-03-21T12:32:36.133Z">
<meta property="article:author" content="browntea">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://browntea.club/2020/03/21/cache/cache/cache.png">
  
    <link rel="alternate" href="/atom.xml" title="布朗与茶的空间" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">布朗与茶的空间</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://browntea.club"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/cache/" class="article-date">
  <time datetime="2020-03-21T09:36:43.000Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      缓存介绍
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下信息及图片收集于网络， 此处仅做整合</p>
<h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><hr>
<p>缓： 缓冲，缓解矛盾 （不是缓慢，反而应该是除CPU/GPU之外最快的）</p>
<p>存：占有储存空间资源</p>
<p>缓存：缓存就是数据交换的缓冲区。临时存贮的那些交换频繁的数据/文件，以便于快速的访问。</p>
<p>缓存的介质类型</p>
<ul>
<li>内存型缓存</li>
<li>文件型缓存</li>
<li>数据库型缓存</li>
</ul>
<p>???</p>
<a id="more"></a>

<h1 id="有哪些缓存"><a href="#有哪些缓存" class="headerlink" title="有哪些缓存"></a>有哪些缓存</h1><hr>
<p>缓存的类型很多， 从访问的开始到结束 ，各个layer理论上都可以有缓存。</p>
<p><img src="cache/cache.png" alt="cache/cache.png"></p>
<p><img src="cache/cache%201.png" alt="cache/cache%201.png"></p>
<p><img src="cache/cache%202.png" alt="cache/cache%202.png"></p>
<ul>
<li><p>CPU的缓存</p>
<h3 id="CPU的缓存"><a href="#CPU的缓存" class="headerlink" title="CPU的缓存"></a>CPU的缓存</h3><hr>
<p>  最简单的调整缓存 配置图</p>
<p>  <img src="cache/cache%203.png" alt="cache/cache%203.png"></p>
<p>  三级缓存的处理器</p>
<p>  <img src="cache/cache%204.png" alt="cache/cache%204.png"></p>
<p>  图3.3 多处理器、多核心、多线程</p>
<hr>
<p>  <img src="cache/cache%205.png" alt="cache/cache%205.png"></p>
<p>  <img src="cache/cache%206.png" alt="cache/cache%206.png"></p>
</li>
</ul>
<h3 id="Linux文件缓存"><a href="#Linux文件缓存" class="headerlink" title="Linux文件缓存"></a>Linux文件缓存</h3><hr>
<pre><code>wuab@iuc01:~$ free -m
              total        used        free      shared  buff/cache   available
Mem:          31986       20049         551        1330       11385       11815
Swap:             0           0           0</code></pre><p><img src="cache/v2-e295352c7273887832b6beb185597460_1200x500.jpg" alt="cache/v2-e295352c7273887832b6beb185597460_1200x500.jpg"></p>
<p>Mem：表示物理内存统计。<br>total：表示物理内存总量(total = used + free)。<br>used：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用。<br>free：未被分配的内存。<br>shared：共享内存。<br>buffers：系统分配但未被使用的buffers数量。<br>cached：系统分配但未被使用的cache数量。<br>-/+ buffers/cache：表示物理内存的缓存统计。<br>used2：也就是第一行中的used – buffers - cached也是实际使用的内存总量。 // used2为第二行<br>free2 = buffers1 + cached1 + free1 // free2为第二行，buffers1等为第一行<br>free2：未被使用的buffers与cache和未被分配的内存之和，这就是系统当前实际可用内存。<br>Swap：表示硬盘上交换分区的使用情况。</p>
<p>在Free命令中显示的buffer和cache，它们都是占用内存：</p>
<p>buffer : 作为buffer cache的内存，是块设备的读写缓冲区，更靠近存储设备，或者直接就是disk的缓冲区。</p>
<p>cache: 作为page cache的内存, 文件系统的cache，是memory的缓冲区 。</p>
<p>如果cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小 。</p>
<p>在 Linux 中，当App需要读取Disk文件中的数据时，Linux先分配一些内存，将数据从Disk读入到这些内存中，然后再将数据传给App。当需要往文件中写数据时，Linux先分配内存接收用户数据，然后再将数据从内存写到Disk上。Linux Cache 管理指的就是对这些由Linux分配，并用来存储文件数据的内存的管理。</p>
<p>下图描述了 Linux 中文件 Cache 管理与内存管理以及文件系统的关系。从图中可以看到，在 Linux 中，具体的文件系统，如 ext2/ext3/ext4 等，负责在文件 Cache和存储设备之间交换数据，位于具体文件系统之上的虚拟文件系统VFS负责在应用程序和文件 Cache 之间通过 read/write 等接口交换数据，而内存管理系统负责文件 Cache 的分配和回收，同时虚拟内存管理系统(VMM)则允许应用程序和文件 Cache 之间通过 memory map的方式交换数据，FS Cache底层通过SLAB管理器来管理内存。</p>
<p><img src="cache/cache%207.png" alt="cache/cache%207.png"></p>
<h3 id="浏览器的缓存"><a href="#浏览器的缓存" class="headerlink" title="浏览器的缓存"></a>浏览器的缓存</h3><hr>
<p><img src="cache/cache%208.png" alt="cache/cache%208.png"></p>
<p><img src="cache/cache%209.png" alt="cache/cache%209.png"></p>
<p><img src="cache/cache%2010.png" alt="cache/cache%2010.png"></p>
<h3 id="代理服务器的缓存"><a href="#代理服务器的缓存" class="headerlink" title="代理服务器的缓存"></a>代理服务器的缓存</h3><hr>
<p><img src="cache/cache%2011.png" alt="cache/cache%2011.png"></p>
<h3 id="CDN的缓存"><a href="#CDN的缓存" class="headerlink" title="CDN的缓存"></a>CDN的缓存</h3><hr>
<p><img src="cache/cache%2012.png" alt="cache/cache%2012.png"></p>
<p><img src="cache/cache%2013.png" alt="cache/cache%2013.png"></p>
<h3 id="AliCDN架构"><a href="#AliCDN架构" class="headerlink" title="AliCDN架构"></a>AliCDN架构</h3><hr>
<p><img src="cache/cache%2014.png" alt="cache/cache%2014.png"></p>
<p><img src="cache/cache%2015.png" alt="cache/cache%2015.png"></p>
<p><a href="cache/cdn-brief-manual-cn-zh-2016-05-11.pdf">cdn-brief-manual-cn-zh-2016-05-11.pdf</a></p>
<h2 id="缓存的模式"><a href="#缓存的模式" class="headerlink" title="缓存的模式"></a>缓存的模式</h2><hr>
<p><img src="cache/cache%2016.png" alt="cache/cache%2016.png"></p>
<h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><hr>
<p>缓存与数据库的异构导致事务不一致，更新事务未结束时，读操作造成脏数据 ，尤其在事务很慢的时候。 <br>可以使用2PC或者Paxios协议保证一致性，但2PC太慢， Paxios太复杂。 <br>当前模式相对概率会低点（但在医时的情况下严重些）</p>
<p><img src="cache/cache%2017.png" alt="cache/cache%2017.png"></p>
<h3 id="Write-Behind-Pattern"><a href="#Write-Behind-Pattern" class="headerlink" title="Write Behind Pattern"></a>Write Behind Pattern</h3><hr>
<p>实现逻辑比较复杂，需要track哪些需要刷到持久层的<br>数据不是强一致，可能会丢失</p>
<p><img src="cache/cache%2018.png" alt="cache/cache%2018.png"></p>
<h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><hr>
<p>缓存与数据库的异构导致事务不一致，更新事务未结束时，读操作造成脏数据 ，尤其在事务很复杂很慢的时候</p>
<p><img src="cache/cache%2019.png" alt="cache/cache%2019.png"></p>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><hr>
<p><img src="cache/cache%2020.png" alt="cache/cache%2020.png"></p>
<h1 id="缓存的关键"><a href="#缓存的关键" class="headerlink" title="缓存的关键"></a>缓存的关键</h1><hr>
<ul>
<li>时间</li>
<li>成本</li>
</ul>
<h1 id="缓存的难点"><a href="#缓存的难点" class="headerlink" title="缓存的难点"></a>缓存的难点</h1><hr>
<ul>
<li>数据的有效性(置换/过期)</li>
<li>数据的一致性： AP + 最终一致</li>
</ul>
<h1 id="缓存的置换策略"><a href="#缓存的置换策略" class="headerlink" title="缓存的置换策略"></a>缓存的置换策略</h1><hr>
<ul>
<li><p><strong>Least Frequently Used(LFU)</strong><br>将访问次数最少的内容替换出Cache。</p>
</li>
<li><p><strong>Least Recently User(LRU)</strong><br>将最近最少使用的内容替换出Cache。</p>
</li>
<li><p><strong>Two Queues(2Q)</strong><br>把被访问的数据放到一个缓存中（FIFO），如果这个对象再一次被访问，就把他转移到第二个、更大的LRU缓存。</p>
</li>
<li><p><strong>Multi Queue(MQ)</strong><br>MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：优先缓存访问次数多的数据</p>
</li>
<li><p><strong>Adaptive Replacement Cache</strong><br>由2个LRU组成，第一个LRU包含最近只被使用过一次的对象，第二个LRU包含最近访问超过两次以上的对象。因此，L1放的是新的对象， L2放的是常用的对象。</p>
</li>
<li><p><strong>First in First out (FIFO)， Second Chance ， Clock</strong><br>先进先出。<br>FIFO增强版， 设置标志位，清除前如果已经使用过则清除标志位并新增至队列<br>环形列表，</p>
</li>
<li><p><strong>Simple time-based</strong><br>通过绝对的时间周期去失效缓存对象。</p>
</li>
<li><p><strong>Extended time-based expiration</strong><br>通过相对时间失效缓存对象。</p>
</li>
<li><p><strong>Sliding time-based expiration</strong><br>缓存对象的生命起点是在这个缓存的最后被访问时间算起</p>
</li>
</ul>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a><strong>缓存更新</strong></h1><hr>
<p>一般来说缓存的更新有两种情况:</p>
<ul>
<li>先删除缓存，再更新数据库。</li>
<li>先更新数据库，再删除缓存。</li>
</ul>
<h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a><strong>先删除缓存，再更新数据库</strong></h2><p>对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。</p>
<p><a href="https://camo.githubusercontent.com/cc391f324d9d4e2bb72b2b45c2482a91bc2408a8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363030653437386130616561373f773d3131303926683d36313126663d706e6726733d3536383933" target="_blank" rel="noopener">https://camo.githubusercontent.com/cc391f324d9d4e2bb72b2b45c2482a91bc2408a8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363030653437386130616561373f773d3131303926683d36313126663d706e6726733d3536383933</a></p>
<p>对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。</p>
<p>先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成Cache Miss。</p>
<h2 id="4先更新数据库，再删除缓存-推荐"><a href="#4先更新数据库，再删除缓存-推荐" class="headerlink" title="4先更新数据库，再删除缓存(推荐)"></a>4<strong>先更新数据库，再删除缓存(推荐)</strong></h2><p>如果我们使用更新数据库，再删除缓存就能避免上面的问题。但是同样的引入了新的问题,试想一下有一个数据此时是没有缓存的，所以查询请求会直接落库，更新操作在查询请求之后，但是更新操作删除数据库操作在查询完之后回填缓存之前，就会导致我们缓存中和数据库出现缓存不一致。</p>
<p>为什么我们这种情况有问题，很多公司包括Facebook还会选择呢？因为要触发这个条件比较苛刻。</p>
<ol>
<li>首先需要数据不在缓存中。</li>
<li>其次查询操作需要在更新操作先到达数据库。</li>
<li>最后查询操作的回填比更新操作的删除后触发，这个条件基本很难出现，因为更新操作的本来在查询操作之后，一般来说更新操作比查询操作稍慢。但是更新操作的删除却在查询操作之后，所以这个情况比较少出现。</li>
</ol>
<p>对比之前的问题来说这种问题的概率很低，况且我们有超时机制保底所以基本能满足我们的需求。如果真的需要追求完美，可以使用二阶段提交，但是其成本和收益一般来说不成正比。</p>
<h1 id="缓存设计实践"><a href="#缓存设计实践" class="headerlink" title="缓存设计实践"></a><strong>缓存设计实践</strong></h1><hr>
<h2 id="1-Memached-Multiget-Hole-multiget黑洞"><a href="#1-Memached-Multiget-Hole-multiget黑洞" class="headerlink" title="1 Memached Multiget-Hole(multiget黑洞)"></a><strong>1 Memached Multiget-Hole(multiget黑洞)</strong></h2><p>在Memcached采用数据分片方式部署的情况下，对于multiget命令来说，部署部署更多的节点，并不能提升multiget的承载量，甚至出现节点数越多，multiget的效率反而会降低，这就是multiget黑洞。这是由于执行multiget命令时，会对每一个节点进行访问，通常SLA取决于最慢最坏的节点，而且节点数增多，出问题的概率也增大，客户端处理的压力也会增大。通常在数据分片时，我们推荐4~8个节点左右。解决multiget黑洞有两种方式可供参考：</p>
<ul>
<li>使用多副本的方式扩容，增加multiget的承载量</li>
<li>通过业务层面来控制，multiget的keys尽可能放在同一个节点上，但具体实施时较难操作，可行性不是很高。</li>
</ul>
<h2 id="2-反向Cache"><a href="#2-反向Cache" class="headerlink" title="2 反向Cache"></a><strong>2 反向Cache</strong></h2><p>反向Cache就是将一个不存在的key放在缓存中，也就是在缓存中存一个空值。在某些场景下，比如微博维度的计数场景，若采用cache+DB的存储方式，由于大多数的微博并不存在转发、评论计数，这种场景下，就会出现由于大量访问不存在计数的mid，导致DB压力居高不下的情况。通过在cache中存一个null值，可减少对DB的穿透。当然这也存在潜在的风险或问题：</p>
<ul>
<li>如果每次都是不同的mid，缓存效果可能不明显</li>
<li>需要更多的缓存容量</li>
</ul>
<h2 id="3-缓存Fail-Fast-快速失败"><a href="#3-缓存Fail-Fast-快速失败" class="headerlink" title="3 缓存Fail-Fast (快速失败)"></a><strong>3 缓存Fail-Fast (快速失败)</strong></h2><p>当缓存层某个节点出现故障时，会导致请求持续穿透到存储层，使请求响应时间长(需要等到读写故障缓存节点超时)，并且存储层负载居高不下。这就需要在使用缓存时考虑快速失败机制。快速失败指的是：当出现故障节点时，标识故障节点为不可用节点（策略举例：连续N次请求都出现超时，标识M时间段内为不可用)，读写不可用节点快速返回。通过快速失败策略，解决请求响应时间长问题，保证SLA。</p>
<h2 id="4-缓存无过期-Cache-is-Storage"><a href="#4-缓存无过期-Cache-is-Storage" class="headerlink" title="4 缓存无过期(Cache is Storage)"></a><strong>4 缓存无过期(Cache is Storage)</strong></h2><p>缓存无过期是指缓存中存储全量数据，不存在数据穿透的情况。 相比于缓存+DB的访问模型，使用内存存储简单可靠，但相应的内存成本也较高。选择内存缓存还是内存存储，需要结合具体的业务场景做权衡，比如单纯为解决Dog-Pile Effect而采用内存存储的话，内存成本可能就无法接受。通常情况下，内存存储模式，适合总体数据量很小，但是访问量巨大的业务场景，比如微博应用(来自weibo.com，weico等)列表。</p>
<h2 id="5-dog-pile-effect-狗桩效应"><a href="#5-dog-pile-effect-狗桩效应" class="headerlink" title="5 dog-pile effect (狗桩效应)"></a><strong>5 dog-pile effect (狗桩效应)</strong></h2><p>狗桩效应是由于极热访问的缓存数据失效，大量请求发现没有缓存，进而穿透至DB，导致数据库load瞬间飙高甚至宕机。这是一个典型的并发访问穿透问题，理想情况下缓存失效对数据库应该只有一次穿透。要解决这个问题，首先从代码层面就要考虑到并发穿透的情况，保证一个进程只有一次穿透；同时，可以考虑使用基于mc的分布式锁来控制。不过使用分布式锁来实现会较为繁琐，通常在代码层面进行控制，就可以得到很好的效果。</p>
<h2 id="6-极热点数据场景"><a href="#6-极热点数据场景" class="headerlink" title="6 极热点数据场景"></a><strong>6 极热点数据场景</strong></h2><p>微博在遇到一些突发事件时(如文章事件)，流量会出现爆发式的增长，大量的热点数集中访问，导致某个缓存资源遇到性能瓶颈(比如明星的数据所在的端口)，最终接口响应变慢影响正常的服务。为了应对这个问题我们在前端使用local cache, 以缓解后端缓存的压力。但是有些业务场景下，由于各种海量业务数据的冲刷，前端使用 local cache，命中率可能不高，性能提升也不明显，这种业务场景下可以考虑引入L1结构，通过部署多组小容量的L1缓存来应对突然的访问量增长。</p>
<h2 id="7-避免雪崩"><a href="#7-避免雪崩" class="headerlink" title="7 避免雪崩"></a><strong>7 避免雪崩</strong></h2><p>雪崩效应是由于缓存服务器宕机等原因导致命中率降低，大量的请求穿透到数据库，导致数据库被冲垮，业务系统出现故障，服务很难再短时间内回复。避免雪崩主要从以下几方面考虑：</p>
<ul>
<li>缓存高可用</li>
</ul>
<p>避免单点故障，保证缓存高命中率</p>
<ul>
<li>降级和流控</li>
</ul>
<p>故障期间通过降级非核心功能来保证核心功能可用性</p>
<p>故障期间通过拒掉部分请求保证有部分请求还能正常响应</p>
<ul>
<li>清楚后端资源容量</li>
</ul>
<p>更好的预知风险点，提前做好准备</p>
<p>即使出现问题，也便于更好的流控(具体应该放量多少)</p>
<h2 id="8-数据一致性"><a href="#8-数据一致性" class="headerlink" title="8 数据一致性"></a><strong>8 数据一致性</strong></h2><p>我们知道，在CAP理论下，只能取其二，而无法保证全部。在分布式缓存中，通常要保证可用性(A)和可扩展性(P)，并折中采用数据最终一致性，最终一致性包括：</p>
<ul>
<li>Master与副本一致性</li>
<li>Cache与Storage一致性</li>
<li>业务各维度缓存数据一致性</li>
</ul>
<h2 id="9-缓存容量规划"><a href="#9-缓存容量规划" class="headerlink" title="9 缓存容量规划"></a><strong>9 缓存容量规划</strong></h2><p>进行缓存容量规划时，主要从以下几个方面进行考虑：</p>
<ul>
<li>请求量</li>
<li>命中率：预热，防止雪崩</li>
<li>网络带宽：网卡、交换机</li>
<li>存储容量：预估存储大小，过期策略、剔除率</li>
<li>连接数</li>
</ul>
<h2 id="10-缓存污染"><a href="#10-缓存污染" class="headerlink" title="10 缓存污染"></a>10 缓存污染</h2><p>缓存污染一般出现在我们使用本地缓存中，可以想象，在本地缓存中如果你获得了缓存，但是你接下来修改了这个数据，但是这个数据并没有更新在数据库，这样就造成了缓存污染:</p>
<p>上面的代码就造成了缓存污染，通过id获取Customer，但是需求需要修改Customer的名字，所以开发人员直接在取出来的对象中直接修改，这个Customer对象就会被污染，其他线程取出这个数据就是错误的数据。</p>
<p><a href="https://camo.githubusercontent.com/e08f244bd67bbc9ec2a062e20f609923d3df3f40/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363230396234306430376164653f773d3132303026683d32393626663d706e6726733d3736323537" target="_blank" rel="noopener">https://camo.githubusercontent.com/e08f244bd67bbc9ec2a062e20f609923d3df3f40/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363230396234306430376164653f773d3132303026683d32393626663d706e6726733d3736323537</a></p>
<p>要想避免这个问题需要开发人员从编码上注意，并且代码必须经过严格的review，以及全方位的回归测试，才能从一定程度上解决这个问题。</p>
<h2 id="11-序列化"><a href="#11-序列化" class="headerlink" title="11 序列化"></a>11 序列化</h2><p>序列化是很多人都不注意的一个问题，很多人忽略了序列化的问题，上线之后马上报出一下奇怪的错误异常，造成了不必要的损失，最后一排查都是序列化的问题。列举几个序列化常见的问题:</p>
<ol>
<li><p>key-value对象过于复杂导致序列化不支持:笔者之前出过一个问题，在美团的Tair内部默认是使用protostuff进行序列化，而美团使用的通讯框架是thfift，thrift的TO是自动生成的，这个TO里面很多复杂的数据结构，但是将其存放到了Tair中。查询的时候反序列化也没有报错，单测也通过，但是到qa测试的时候发现这一块功能有问题，发现有个字段是boolean类型默认是false，把它改成true之后，序列化到tair中再反序列化还是false。定位到是protostuff对于复杂结构的对象(比如数组，List等等)支持不是很好，会造成一定的问题。后来对这个TO进行了转换，用普通的Java对象就能进行正确的序列化反序列化。</p>
</li>
<li><p>添加了字段或者删除了字段，导致上线之后老的缓存获取的时候反序列化报错，或者出现一些数据移位。</p>
</li>
<li><p>不同的JVM的序列化不同，如果你的缓存有不同的服务都在共同使用(不提倡)，那么需要注意不同JVM可能会对Class内部的Field排序不同，而影响序列化。比如下面的代码，在Jdk7和Jdk8中对象A的排列顺序不同，最终会导致反序列化结果出现问题:</p>
<p> //jdk 7<br> class A{</p>
<pre><code>int a;
int b;</code></pre><p> }<br> //jdk 8<br> class A{</p>
<pre><code>int b;
int a;</code></pre><p> }</p>
</li>
</ol>
<p>序列化的问题必须得到重视，解决的办法有如下几点:</p>
<ol>
<li>测试:对于序列化需要进行全面的测试，如果有不同的服务并且他们的JVM不同那么你也需要做这一块的测试，在上面的问题中笔者的单测通过的原因是用的默认数据false，所以根本没有测试true的情况，还好QA给力，将其给测试出来了。</li>
<li>对于不同的序列化框架都有自己不同的原理，对于添加字段之后如果当前序列化框架不能兼容老的，那么可以换个序列化框架。 对于protostuff来说他是按照Field的顺序来进行反序列化的，对于添加字段我们需要放到末尾，也就是不能插在中间，否则会出现错误。对于删除字段来说，用@Deprecated注解进行标注弃用，如果贸然删除，除非是最后一个字段，否则肯定会出现序列化异常。</li>
<li>可以使用双写来避免，对于每个缓存的key值可以加上版本号，每次上线版本号都加1，比如现在线上的缓存用的是Key_1，即将要上线的是Key_2,上线之后对缓存的添加是会写新老两个不同的版本(Key_1,Key_2)的Key-Value，读取数据还是读取老版本Key_1的数据,假设之前的缓存的过期时间是半个小时，那么上线半个小时之后，之前的老缓存存量的数据都会被淘汰，此时线上老缓存和新缓存他们的数据基本是一样的,切换读操作到新缓存，然后停止双写。采用这种方法基本能平滑过渡新老Model交替，但是不好的点就是需要短暂的维护两套新老Model，下次上线的时候需要删除掉老Model，增加了维护成本。</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr>
<h2 id="Cache-和-Buffer-的区别"><a href="#Cache-和-Buffer-的区别" class="headerlink" title="Cache 和 Buffer 的区别"></a>Cache 和 Buffer 的区别</h2><p><strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。2、<strong>Cache</strong>（缓存）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。3、假定以后存储器访问变得跟CPU做计算一样快，cache就可以消失，但是buffer依然存在。比如从网络上下载东西，瞬时速率可能会有较大变化，但从长期来看却是稳定的，这样就能通过引入一个buffer使得OS接收数据的速率更稳定，进一步减少对磁盘的伤害。4、TLB（Translation Lookaside Buffer，翻译后备缓冲器）名字起错了，其实它是一个cache.</p>
<p>作者：知乎用户链接：<a href="https://www.zhihu.com/question/26190832/answer/32387918来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。" target="_blank" rel="noopener">https://www.zhihu.com/question/26190832/answer/32387918来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
<p>Buffer不是缓存，国内常用的翻译是缓冲区。其次，大部分场景中，Buffer是特指内存中临时存放的IO设备数据——包括读取和写入；而Cache的用处很多——很多IO设备（例如硬盘、RAID卡）上都有Cache，CPU内部也有Cache，浏览器也有Cache。Buffer并非用于提高性能，而Cache的目的则是提高性能。涉及到IO设备读写的场景中，Cache的一部分本身就是Buffer的一种。如果说某些场合Buffer可以提升IO设备的读写性能，只不过是因为Buffer本身是Cache系统的一部分，性能提升来自于Cache机制。Buffer占用的内存不能回收，如果被强行回收会出现IO错误。Cache占用的内存，除实现Buffer的部分外都可以回收，代价则是下一次读取需要从数据的原始位置（通常是性能更低的设备）读取。在IO读写过程中，任何数据的读写都必然会产生Buffer，但根据Cache算法，可能会有相当部分数据不会被Cache。</p>
<p>作者：木头龙链接：<a href="https://www.zhihu.com/question/26190832/answer/825301105来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。" target="_blank" rel="noopener">https://www.zhihu.com/question/26190832/answer/825301105来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
<h2 id="内存数据库与内存共享技术"><a href="#内存数据库与内存共享技术" class="headerlink" title="内存数据库与内存共享技术"></a>内存数据库与内存共享技术</h2><p><img src="cache/cache%2021.png" alt="cache/cache%2021.png"></p>
<h2 id="EHCACHE"><a href="#EHCACHE" class="headerlink" title="EHCACHE"></a>EHCACHE</h2><p><img src="cache/cache%2022.png" alt="cache/cache%2022.png"></p>
<p><img src="cache/cache%2023.png" alt="cache/cache%2023.png"></p>
<p><img src="cache/cache%2024.png" alt="cache/cache%2024.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://browntea.club/2020/03/21/cache/" data-id="ck81f68t8000049sb7l1s20j1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/21/multi-level-cache/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          多级缓存
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/21/multi-level-cache/">多级缓存</a>
          </li>
        
          <li>
            <a href="/2020/03/21/cache/">缓存介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 browntea<br>
       <a href="http://www.beian.miit.gov.cn/" target="_blank">沪ICP备18021205号-1</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>